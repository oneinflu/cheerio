'use strict';
const express = require('express');
const router = express.Router();
const db = require('../../db');
const flowCrypto = require('../utils/flowCrypto');

router.post('/', async (req, res) => {
  try {
    // 1. Get Private Key
    const settingsRes = await db.query('SELECT private_key FROM whatsapp_flow_settings ORDER BY created_at DESC LIMIT 1');
    if (settingsRes.rowCount === 0) {
      console.error('No private key found for Flow Endpoint');
      return res.status(500).send();
    }
    const privateKeyPem = settingsRes.rows[0].private_key;

    // 2. Decrypt Request
    const { encrypted_aes_key, initial_vector, encrypted_flow_data } = req.body;
    if (!encrypted_aes_key || !initial_vector || !encrypted_flow_data) {
       return res.status(400).send();
    }

    let decryptedBody, aesKey, initialVector;
    try {
      const decrypted = flowCrypto.decryptRequest(req.body, privateKeyPem);
      decryptedBody = decrypted.decryptedBody;
      aesKey = decrypted.aesKey;
      initialVector = decrypted.initialVector;
    } catch (err) {
      console.error('Decryption failed:', err);
      return res.status(401).send();
    }
    
    console.log('Flow Request:', JSON.stringify(decryptedBody, null, 2));

    // 3. Process Request
    const { action, data, screen, version } = decryptedBody;
    let responseData = {};

    if (action === 'ping') {
      responseData = { data: { status: 'active' } };
    } else if (action === 'INIT') {
      // Return empty data for now, user logic will handle specific flows
      // Default to 'screen_a' as that is the first screen generated by FlowsCreate.jsx
      responseData = {
        screen: 'screen_a', 
        data: {}
      };
    } else if (action === 'data_exchange') {
      // Basic echo logic for now - in production this would dispatch to specific flow handlers
      responseData = {
        screen: screen,
        data: { ...data }
      };
    } else {
       console.error('Unknown flow action:', action);
       // Return empty to avoid crashing
       responseData = {}; 
    }

    // 4. Encrypt Response
    const encryptedResponse = flowCrypto.encryptResponse(responseData, aesKey, initialVector);

    // Return plain text string as body (not JSON object with property)
    res.set('Content-Type', 'text/plain');
    res.status(200).send(encryptedResponse);

  } catch (err) {
    console.error('Flow Endpoint Error:', err);
    res.status(500).send();
  }
});

module.exports = router;
